"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, Nicholas Trota, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: nkt425
"""


def group_sum(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case: starting index is OOB; perform the check
    if start > len(nums) - 1:
        return target == 0

    # path A: use nums[start] to adjust the target down
    include_start = group_sum(start + 1, nums, target - nums[start])
    # path B: do not use nums[start] to adjust the target down, and skip to the next num
    exclude_start = group_sum(start + 1, nums, target)

    # by the end, we will generate all possible subset combination sums.
    # if any returned true, they work their way back up the chain and are seen
    # as the final result
    return include_start or exclude_start


def group_sum_6(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target. Additionally, if there is are 6's present in the array, they must all
    be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case: starting index is OOB; perform the check
    if start > len(nums) - 1:
        return target == 0

    # path A: use nums[start] to adjust the target down
    include_start = group_sum_6(start + 1, nums, target - nums[start])
    # path B: do not use nums[start] to adjust the target down, and skip to the next num
    # ignore exclusion branch when num is 6
    if nums[start] != 6:
        exclude_start = group_sum_6(start + 1, nums, target)
    else:
        exclude_start = False

    # by the end, we will generate all possible subset combination sums.
    # if any returned true, they work their way back up the chain and are seen
    # as the final result
    return include_start or exclude_start


def group_no_adj(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a value is chosen, the value immediately after
    (the value adjacent) cannot be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case: starting index is OOB; perform the check
    if start > len(nums) - 1:
        return target == 0

    # path A: use nums[start] to adjust the target down
    # if we adjust, increment our start value by 2 in order to skip the next num
    include_start = group_no_adj(start + 2, nums, target - nums[start])
    # path B: do not use nums[start] to adjust the target down, and skip to the next num
    exclude_start = group_no_adj(start + 1, nums, target)

    # by the end, we will generate all possible subset combination sums.
    # if any returned true, they work their way back up the chain and are seen
    # as the final result
    return include_start or exclude_start


def group_sum_5(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a multiple of 5 is in the array, it must be included
    If the value immediately following a multiple of 5 if 1, it must not be chosen

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case: starting index is OOB; perform the check
    if start > len(nums) - 1:
        return target == 0

    # path A: use nums[start] to adjust the target down
    # if nums[start] is 1, is not the first index, and the index before is a multiple of 5,
    # do not include this branch
    if nums[start] == 1 and start != 0 and nums[start - 1] %  5 == 0:
        include_start = False
    else:
        include_start = group_sum_5(start + 1, nums, target - nums[start])
    # path B: do not use nums[start] to adjust the target down, and skip to the next num
    # ignore exclusion branch when num is multiple of 5
    if nums[start] %  5 != 0:
        exclude_start = group_sum_5(start + 1, nums, target)
    else:
        exclude_start = False

    # by the end, we will generate all possible subset combination sums.
    # if any returned true, they work their way back up the chain and are seen
    # as the final result
    return include_start or exclude_start


def group_sum_clump(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if there is a group of identical numbers in succession,
    they must all be chosen, or none of them must be chosen.
    EX: [1, 2, 2, 2, 5, 2], all three of the middle 2's must be chosen, or none of them must be
    chosen to be included in the sum. One loop is allowed to check for identical numbers.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case: starting index is OOB; perform the check
    if start > len(nums) - 1:
        return target == 0

    # Let i be the number of times "start" repeats.
    # Then it will be the amount of spaces we jump on the next iteration
    # and the multiplier by which target is affected.
    i = 1
    while start + i < len(nums) and nums[start + i] == nums[start]:
        i += 1

    # path A: use nums[start] to adjust the target down
    include_start = group_sum_clump(start + i, nums, target - (nums[start] * i) )
    # path B: do not use nums[start] to adjust the target down, and skip to the next num
    exclude_start = group_sum_clump(start + i, nums, target)

    # by the end, we will generate all possible subset combination sums.
    # if any returned true, they work their way back up the chain and are seen
    # as the final result
    return include_start or exclude_start


def split_array(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    # For each number in nums, we put it into either sum a or sum b
    # Then once there are no more nums, return if sum a = sum b

    def summation_path(i, sum_a, sum_b):
        # base case: nums is empty
        if i > len(nums) - 1:
            return sum_a == sum_b

        # path A: put the current num into sum a
        include_a = summation_path(i + 1, sum_a + nums[i], sum_b)
        # path B: put the current num into sum b
        include_b = summation_path(i+1, sum_a, sum_b + nums[i])

        # at the end of a path, we return if the sums ended up equal.
        # if yes, return True (it will come back up the chain).
        # if no, return False
        return include_a or include_b

    return summation_path(0, 0, 0)


def split_odd_10(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of one group must be odd, while the other group must be a multiple of 10
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    # For each number in nums, we put it into either sum a or sum b
    # Then once there are no more nums, return if sum a % 10 == 0
    # and sum b % 2 != 0

    def summation_path(i, sum_a, sum_b):
        # base case: nums is empty
        if i > len(nums) - 1:
            return sum_a % 10 == 0 and sum_b % 2 != 0

        # path A: put the current num into sum a (mod 10)
        include_a = summation_path(i + 1, sum_a + nums[i], sum_b)
        # path B: put the current num into sum b (mod 2)
        include_b = summation_path(i+1, sum_a, sum_b + nums[i])

        # at the end of a path, we return if the sums ended up as desired.
        # if yes, return True (it will come back up the chain).
        # if no, return False
        return include_a or include_b

    return summation_path(0, 0, 0)


def split_53(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Additionally, all multiples of 5 must be in one group, and all multiples of 3 (and not 5)
    must be in the other group
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    # For each number in nums, we put it into either sum a or sum b
    # Then once there are no more nums, return if sum a = sum b

    def summation_path(i, sum_a, sum_b):
        # base case: nums is empty
        if i > len(nums) - 1:
            return sum_a == sum_b

        # path A: put the current num into sum a.
        # If multiple of 5, do not do this.
        if nums[i] % 5 == 0:
            include_a = False
        else:
            include_a = summation_path(i + 1, sum_a + nums[i], sum_b)
        # path B: put the current num into sum b.
        # If multiple of 3, do not do this.
        if nums[i] % 3 == 0:
            include_b = False
        else:
            include_b = summation_path(i+1, sum_a, sum_b + nums[i])

        # at the end of a path, we return if the sums ended up equal.
        # if yes, return True (it will come back up the chain).
        # if no, return False
        return include_a or include_b

    if len(nums) == 0: # a fix for what may be a typo in the test list
        return False
    return summation_path(0, 0, 0)
